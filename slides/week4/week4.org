#+TITLE: Week 4
#+AUTHOR: Kristaps Berzinch, Raymond Ortiz, Sahit Chintalapudi
#+EMAIL: kristaps@robojackets.org, rortiz9@gatech.edu, schintalapudi@gatech.edu

* What are we doing today?
- How a program's memory is structured and maintained
- References and pointers
- How to convert objects between different types
- No =git= slides this week!
- TODO hardware application

* What is the output?
#+BEGIN_NOTES
Ask them the output of this code. Then talk about how var and a are not the same place in memory.
#+END_NOTES
#+BEGIN_SRC c++
#include <iostream>
int increment(int a) {
  a = a + 5;
}
int main() {
  int var = 5;
  increment(var);
  std::cout << var << std::endl;
}
#+END_SRC

* Memory structure
#+BEGIN_NOTES
Make sure to emphasize how important memory allocation is for any real program. This is all fundamentally the same RAM, just arranged and managed in a certain way. Static memory is used for static/global variables. A new block is allocated when a function is called, and released when the function exits - this is where your parameters and local variables are stored. Mention memory leaks.
#+END_NOTES
- At a high level, your program has three kinds of memory
 - *Static memory:* calculated at compile time
 - *The stack:* managed automatically by the language
 - *The heap:* your space to do whatever you want
  - You can ask for memory from the OS and return it
    - The heap is managed at runtime
  - You have to keep track of what you've allocated to avoid memory leaks
- At an even higher level, all the memory in your computer is a huge, indexable, iterable space, divided into bytes

** What is a byte
#+BEGIN_NOTES
They may never have seen bianry before
#+END_NOTES
- 8 bits (0,1)
  - 00101010
  - 00010001
- smallest indexable space on your computer

** Object lifetimes stack
#+BEGIN_NOTES
talk about how in the below example the int is allocated on the stack
#+END_NOTES
- All variables have different lifetimes depending on where they are allocated in memory
#+BEGIN_SRC c++
#include <iostream>
void increment(int a) {
  a = a + 5;
}
int main() {
  int var = 5;
  increment(var);
  std::cout << var << std::endl;
}
#+END_SRC

* References
#+BEGIN_NOTES
Parameters are copied into the new block so the function can't modify anything outside of its scope. Explicitly using a reference allows a function to do that.
Performance can also improve, since you're only copying a memory address instead of a (potentially) larger object. Run through some basic examples here.
#+END_NOTES
- A reference is a variable that points to the same content as another variable
- Why would you want that?
 - Share data across functions
 - Improve performance
- You can't change where a reference points after initialization
- You can mostly just treat references exactly like normal variables once they're initialized

** Picture
- TODO picture

** Passing by reference
#+BEGIN_NOTES
Show them this example and then walk them through it. with reference to previous slide.
#+END_NOTES
#+BEGIN_SRC c++
#include <iostream>
void increment(int &a) {
  a = a + 5;
}
int main() {
  int var = 5;
  increment(var);
  std::cout << var << std::endl;
}
#+END_SRC

* Pointers
#+BEGIN_NOTES
Run through some basic examples here. Pointers are great for passing around heap objects, but how do you keep track of what objects are still in use?
#+END_NOTES
- A pointer is a special type of variable that "points to" another variable
  - the pointer variable stores the address of a variable
- How are these different from references?
 - You have to explicitly get the value a pointer is pointing to
 - You can change where a pointer is pointing

** Picture
- TODO picture

* Dereferencing pointers
- gets the value pointed to
  - here is an address, what is there?
- TODO picture

* Pointer arithmatic
- In c++ different datatypes have different sizes
| =type= | =# bytes= |
|--------+-----------|
| char   |         1 |
| int    |         4 |
| double |         8 |

** Picture
- A pointer will increment with the size of variables pointer it is in bytes

* New / Delete
- To allocate memory on the heap you can use *new*
  - be careful how much you allocate
  - returns a pointer to the memory
- To deallocate the memory you must use delete
  - anytime memory is allocated you must deallocate it
  - this is the cause of memoryu leaks
    - stay tuned for a demo

** New
#+BEGIN_SRC c++
int main() {
  A *a = new A();
}
#+END_SRC
- TODO picture

** Delete
#+BEGIN_SRC c++
int main() {
  A *a = new A();
  delete a;
}
#+END_SRC
- TODO picture

* Smart pointers
#+BEGIN_NOTES
Each type has an initialization function. Run through some basic examples here.
#+END_NOTES
- Wrap a normal pointer to make it easier to manage the lifecycle of objects
- You should generally use one of these two types instead of a normal pointer:
 - =shared_ptr=: multiple =shared_ptr= s can own a single object
 - =unique_ptr=: only one =unique_ptr= can own an object

** unique_ptr
#+BEGIN_NOTES
object is a struct defined in week4.h
#+END_NOTES
#+BEGIN_SRC c++
int main() {
  unique_ptr<object> unqiue_ptr = make_unique<object>();
}
#+END_SRC
- TODO picture with code to show what is pointing where

** shared_ptr
#+BEGIN_SRC c++
int main() {
  shared_ptr<object> shared_ptr1 = make_shared<object>(); // <--- here
  {
    shared_ptr<object> shared_ptr2 = make_shared<object>();
  }
  shared_ptr<object> shared_ptr3 = make_shared<object>();
}
#+END_SRC
- TODO picture with code to show when it goes away

*** shared_ptr
#+BEGIN_SRC c++
#+BEGIN_SRC c++
int main() {
  shared_ptr<object> shared_ptr1 = make_shared<object>();
  {
    shared_ptr<object> shared_ptr2 = make_shared<object>(); // <--- here
  }
  shared_ptr<object> shared_ptr3 = make_shared<object>();
}
#+END_SRC
- TODO picture with code to show when it goes away

*** shared_ptr
#+BEGIN_SRC c++
#+BEGIN_SRC c++
int main() {
  shared_ptr<object> shared_ptr1 = make_shared<object>();
  {
    shared_ptr<object> shared_ptr2 = make_shared<object>();
  }
  shared_ptr<object> shared_ptr3 = make_shared<object>(); // <--- here
}
#+END_SRC
- TODO picture with code to show when it goes away

* Ownership
- be careful about using shared pointers
  - who owns what?

* Casting, the wrong way
- Sometimes you want to convert a variable to a different type: this is called casting
- In C, you can simply change the type of a variable like so:
#+BEGIN_SRC c++
B* old_var = new B(); // some object
A* new_var = (A*)old_var;
#+END_SRC
 - The compiler will now treat the bytes of object =old_var= as though it was of type =A=
 - This is bad for type safety!

* Type Safety
#+BEGIN_SRC c
      char c = 10;                        // this is one byte in memory

      int *p = (int*) &c;                 // this is a 4-byte pointer pointing to one byte of
                                          // memory - it compiles but leads to corrupted memory
                                          // if you try to write to what p points to

      int *q = static_cast<int*>(&c);     // throws an exception at compile time
#+END_SRC
- Our second cast was type-safe, the first one was not
- Type safety is a language feature that ensures that every variable you handle is actually the type you think it is
 - The compiler will check each time you assign a variable to ensure the types are compatible

* Casting, the right way
#+BEGIN_NOTES
TODO info on why type safety is so important
#+END_NOTES
- C++ gives us functions that are type-safe, including compile-time checks
 - =static_cast= is mostly used for basic type conversions, e.g. between different types of numbers
 - =dynamic_cast= is mostly used for conversions between object types for polymorphism
 - =reinterpret_cast= works like a C-style cast and generally shouldn't be used unless you know exactly what you're doing

* Memory Leak
#+BEGIN_NOTES
run a program that creates a lot of doubles while showing your memory usage. files may corrupt so make sure everything is closed beforehand
#+END_NOTES
- DO NOT TRY THIS AT HOME

* Questions?
- Ask here or on Piazza!
